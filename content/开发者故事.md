# 大三实习生入职一周实现 3 个算子：我的华为 CANN 开源实习成长记

## 1. 从“自娱自乐”到方向锚定

作为北京邮电大学人工智能专业的一名普通大三学生，我没有亮眼的算法竞赛经历，也算不上天赋型选手，但对新知识始终抱着一份向往。每当课内教学触达边界，或是偶然刷到陌生的技术概念时，我总忍不住追根究底——打开 AI 工具请教背后的原理，梳理成清晰的学习路线，再模仿网络上大牛的样子，把零散的知识点整理成笔记或短文。

这些内容或许在专业人士看来只是“自娱自乐”，但一步步搭建起的个人知识库，却成了我自学之路的起点。

转机出现在一场校园宣讲会上。当主讲人提到“AI Infra”这个概念时，我瞬间被吸引了——在此之前的自学中，我曾粗浅接触过深度学习系统，对其底层的机器学习编译更是充满好奇，总觉得那些“看不见的底层逻辑”藏着技术的核心魅力。

可随着学习不断深入，我也陷入了瓶颈：没有导师指引，缺少志同道合的伙伴，很多难题即便反复和 AI 对话，也找不到突破口。就在这时，我萌生了找一份实习的想法：我想走进真实的开发场景，在实践中解开疑惑，也想为自己后续的学习找一个明确的方向。

## 2. CANN 初接触：从“手足无措”到“渐入佳境”

加入华为 CANN 团队前，我完全是个“开源小白”。之前自己折腾代码时，顶多建个 repo 当网盘用，对 PR、CI 这些流程一无所知，甚至连“团队协作”的概念都很模糊。

刚接触 Tilelang-Ascend 开发时，我更是手足无措：第一次面对如此大规模的代码库，还要适配全新的昇腾硬件，报错了不知道怎么定位，调试时摸不清修改逻辑，哪怕是一个简单的功能，都不知道从哪里下手。

好在导师很耐心，没有给我安排复杂的任务，而是从简单的算子开发入手，还特意让我参考仓库里的范例代码。我抱着“临摹”的心态，一行行研读前辈的代码，一点点理清逻辑。

在开发算子时，我们实际上需要写一个工厂函数，它的返回值是一个 kernel，我们需要用修饰器来指明哪个参数是返回值、框架设置、声明原语等等。而在算子内部，需要应用分块思想分而治之，但对于一些需要跨块整合的数据，又得特别处理，着实麻烦。

最后对照着算法伪代码，逐行理清逻辑，总算成功实现。就这样慢慢的，我也实现了几个简单的算子。在反复调试的过程中，之前觉得繁杂的报错，也能顺着文档和日志找到解决思路，若是接口问题，那我就去翻查 AscendC 文档，若是前端问题，那我就重新检查代码。一步步下来，我也逐渐摸清了 Tilelang-Ascend 的运作原理。

## 3. 算子开发经验分享：从原理到实践拆解

据同事们所言，我对于算子开发的上手速度算是比较快的，在此也把我的经验拆解开，和大家详细分享。

### 3.1 先搞懂基础：NPU 结构特性与 Tile 分块逻辑

想要做好 Tilelang 算子开发，首先要理解 NPU 的结构特性。我们可以用 GPU 来类比理解：GPU 是 SIMT（单指令多线程）架构，而 NPU 则是 SIMD（单指令多数据）架构，核心特点是一次对一块数据进行操作。

Tilelang 中的“Tile”概念正是基于此设计的——NPU 的每一个核心负责处理一个 Tile。对于简单的 elementwise 操作（逐元素操作），分块处理似乎没什么特殊难度，但对于更复杂的算子（比如 online_softmax），就需要额外设计逻辑来处理跨核心的信息交互问题。

### 3.2 实战案例：online_softmax 算子开发拆解

下面以 online_softmax 为例，结合具体实现逻辑和伪代码，和大家说说复杂算子的适配思路。先给大家放一下完整的参考代码链接：[softmax example](https://github.com/tile-ai/tilelang-ascend/blob/ascendc_pto/examples/softmax/example_online_softmax.py)

#### 3.2.1 核心挑战：“在线”特性 + NPU 架构适配

Online softmax 和普通 softmax 最大的区别在于“在线”特性——它需要处理长序列数据（比如代码中 N=51200 的大维度输入），无法一次性获取全部输入来计算全局统计量（最大值、指数和），只能通过迭代方式逐块更新这些全局信息。

同时还要适配 NPU 的 Tile 分块架构，这就需要解决两个核心问题：一是跨 Tile 的全局依赖（不同 Tile 计算需要共享全局统计量），二是在线迭代的状态维护（每一轮迭代要保存上一轮的全局信息）。

#### 3.2.2 先看核心逻辑：online_softmax 算法伪代码

```python

# 输入：长序列数据 X（维度：M×N，N为大维度），分块大小 block_N
# 输出：softmax 结果 Y
# 初始化全局状态变量
global_max = -infinity  # 全局最大值
global_sum = 0.0        # 全局指数和

# 第一阶段：逐块迭代更新全局统计量
for 每一列块 col_block in X 的列方向分块:
    # 1. 计算当前块内的最大值
    block_max = max(col_block)
    # 2. 更新全局最大值（取当前块最大值与历史全局最大值的较大者）
    new_global_max = max(global_max, block_max)
    # 3. 计算指数项：exp(元素 - 新全局最大值)
    block_exp = exp(col_block - new_global_max)
    # 4. 更新全局指数和：需要适配最大值更新的缩放（避免数值溢出）
    new_global_sum = global_sum * exp(global_max - new_global_max) + sum(block_exp)
    # 5. 保存当前全局状态，用于下一轮迭代
    global_max = new_global_max
    global_sum = new_global_sum

# 第二阶段：逐块计算最终 softmax 结果
for 每一列块 col_block in X 的列方向分块:
    # 1. 计算归一化项：exp(元素 - 全局最大值) / 全局指数和
    block_softmax = exp(col_block - global_max) / global_sum
    # 2. 将当前块结果写入输出
    Y 对应位置 = block_softmax

return Y
```

#### 3.2.3 Tilelang 适配实现：代码结构与关键步骤

结合上面的伪代码，我们再看 Tilelang-Ascend 的具体实现，核心是通过“双阶段计算 + Tile 内状态维护”来解决核心问题，代码结构可以分为三个关键部分：

**1. 算子封装与编译配置**：通过 `@tilelang.jit` 修饰器封装算子工厂函数，明确输出索引和昇腾相关的编译配置（比如自动同步、内存规划等），这是 Tilelang 算子的标准入口。

**2. Tile 划分与状态变量定义**：核心的 `main` 原语函数定义了 Tile 级的计算逻辑。根据 NPU“一核处理一个 Tile 行”的特性，通过 `T.Kernel(m_num, is_npu=True)` 划分 Tile，每个 Tile 通过 cid（核心 ID）、vid 定位，负责处理 `[sub_block_M, block_N]` 大小的数据块。

同时，在 UB（统一缓冲区，NPU 的本地高速存储）中分配 `prev_max`、`prev_sum` 等状态变量，用于维护迭代过程中的全局信息——这是在线计算的关键，普通分块计算不需要跨迭代保存状态，而 online_softmax 必须通过这些变量记录上一轮的全局最大值和指数和。

**3. 双阶段计算流程落地**：完全对应前面的算法伪代码，在 Tile 级别实现两阶段计算：

第一阶段（逐块更新全局统计量）：通过 `for by in T.serial(n_num)` 遍历所有列块，每个 Tile 先将输入数据加载到 UB 缓冲区 `a` 中，通过 `T.tile.reduce_max` 计算当前 Tile 块内的最大值 `tile_max`，再与上一轮保存的 `prev_max` 取最大值，得到更新后的全局最大值；随后通过 UB 中的 `tmp_exp` 缓冲区完成指数计算与累加，更新全局指数和 `prev_sum`。

这一步所有计算都在 Tile 的 UB 内完成，既利用了 NPU 本地存储的高速读写优势，又通过 `prev_max`、`prev_sum` 的跨迭代保存，实现了“在线”增量计算的需求。

第二阶段（计算最终结果）：基于第一阶段得到的最终全局最大值（`prev_max`）和指数和（`prev_sum`），再次逐块加载输入数据，通过 `T.tile.sub`（减全局最大值）、`T.tile.exp`（指数计算）、`T.tile.div`（除以全局指数和）完成归一化过程，最后将结果写入输出张量 `B`。

#### 3.2.4 总结：Tilelang 算子开发核心思路

其实启动 Tilelang 算子开发的核心逻辑很清晰：先理解 NPU 的 SIMD 架构和 Tile 分块思想，再把目标算法拆解为适配分块计算的逻辑（比如 online_softmax 的双阶段流程），最后通过 Tilelang 的原语函数实现分块处理、状态维护和跨 Tile 交互，就能完成复杂算子的开发。

## 4. 进阶之旅：从“跟随”到“独立解决复杂问题”

后来参与框架功能开发时，我已经能独立应对不少问题。导师让我和他一同进行 T.Parallel 特性的开发，其功能是将用户写的简单 python 风格代码转化成高性能的块操作，我们要在他已经完成的基础版本上支持更多的场景。

在之前的学习过程中，我逐渐建立起了开发思维，面对多样的新场景，没有急着写代码，而是先做需求分析。比如第一个预计支持的列切分场景，分析后发现其实是个伪需求——它可以转化成常规的行切分，和导师讨论后，我们达成了一致，避免了无效开发。

第二个场景是离散索引场景。我同样先分析当前版本无法支持的原因，观察生成的代码后，发现问题出在原来逻辑上的一个小缺陷，修改一行代码后便顺利通过测试。

第三个场景最为复杂，需要支持嵌套表达式。难点在于我们需要为计算中间值申请临时空间，这在 python 侧的前端非常容易实现，但 c++ 侧的实现我之前完全没有接触过。

我依旧先尝试从现有代码中寻找范例，但框架代码不像算子开发有明确的 example，查找了很多申请空间相关的代码，一一尝试后都不能匹配前端对应的逻辑。于是我转向 TVM 的官方文档，终于发现应该通过申请创建 buffer 来实现空间申请，而非单纯的 allocate 语句，同时这些新分配的空间还要注册到对应的 Block 结构当中。

经过一步步地调试，总算成功支持了这个功能的落地——当看到自己的代码顺利运行时，那种成就感，比自学时解开任何一道难题都强烈。

## 5. 总结：从“自学小白”到“实践开发者”的蜕变

这段实习经历，不仅让我解锁了 PR、CI、算子开发这些实打实的技能，更让我跳出了“独自摸索”的小圈子。我开始明白，开源社区不只是代码的集合地，更需要大家一起思考如何扩大用户范围、搭建交流平台，才能让生态繁荣起来；而技术成长也从来不是“一个人的战斗”，前辈的指引、团队的协作，能让新手少走很多弯路。

从靠着 AI 咨询自学的“小白”，到能在 Tilelang-Ascend 开发中贡献力量的实践者，这段旅程让我明白：天赋和过往经历从来不是限制成长的枷锁，保持对知识的热爱、敢于迈出实践的第一步，就会有不一样的收获。

未来，我想继续深耕 AI Infra 领域，带着这段实习的收获，在自学与实践中不断积累，努力从“稚嫩新手”慢慢成长为能独当一面的开发者，在技术的道路上稳步前行。

> （注：文档部分内容可能由 AI 生成）
